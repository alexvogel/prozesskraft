#!/usr/bin/perl
#============================================================================
# processcraft:meta:begin:auto:327235417732353367820908741306819537657
#----------------------------------------------------------------------------
# generated by codegen-core on 2014-02-04 12:56:11.06
my $version = "[% version %]";
my $date = "[% date %]";
#----------------------------------------------------------------------------
# processcraft:meta:end
#============================================================================
#============================================================================
# processcraft:modules:begin:auto:236040018073478824820536733427860890234
#----------------------------------------------------------------------------
use warnings;
use strict;
use Getopt::Long;
Getopt::Long::Configure("pass_through");
use File::Spec;
use Cwd;
#----------------------------------------------------------------------------
# processcraft:modules:end
#============================================================================
#============================================================================
# processcraft:path:begin:auto:248899905101117578691695302185322217721
#----------------------------------------------------------------------------
# feststellen des installationsortes des scripts
my ($filename, $directories, $suffix);
BEGIN
{
    use File::Basename;
    ($filename, $directories, $suffix) = fileparse ($0);
}

# autoflush
$|=1;

# feststellen des installationsortes des programmes
$directories = File::Spec->rel2abs($directories);
my $installdir = $directories . "/..";
my $etcdir = $installdir . "/etc";
my $docdir = $installdir . "/doc";
my $bindir = $directories;

# einbinden der avoge module
# zuerst, falls aus installationsverzeichnis gesucht wird
use lib $directories . "../../../myperllib/master/lib";
# falls aus eclipse gesucht wird
use lib $directories . "../../myperllib/lib";
# falls aus installationsverzeichnis das eigene lib gesucht wird (wird benoetigt falls die zentrale version nicht mehr passt)
use lib $directories . "../myperllib/lib";
# falls aus installationsverzeichnis cb2-scripts
use lib $directories . "../../../../cb2common/lib/1.0";

# path to configurationfile
my $conf_path = $etcdir . "/" . $filename.".conf";
# path to documentation
my $doc_path = $docdir . "/" . $filename.".pdf";
#----------------------------------------------------------------------------
# processcraft:path:end
#============================================================================
#============================================================================
# processcraft:options:begin:auto:79491413802750267722852089913063011362
#----------------------------------------------------------------------------
my %OPT;
my %OPTHELP;
my %optionsall;
# defaultoptions
# hier koenne alle 'festen' optionen definiert werden
my %OPTIONS_TABLE = (
# definition der standardoptions
				'h' => {'reihenfolge' => '9', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'', 'default' => '', 'text1' => '', 'text2' => 'gibt diesen hilfetext aus'},
				'doc'  => {'reihenfolge' => '8', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'', 'default' => '', 'text1' => '', 'text2' => 'falls eine dokumentation existiert, wird diese angezeigt'},
				'log'  => {'reihenfolge' => '7', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'string', 'check'=>'', 'default' => '', 'text1' => '=FILE', 'text2' => 'statt auf STDERR koennen logging-ausgaben in eine datei umgeleitet werden'},

# definition der standardoptions
				'hh' => {'reihenfolge' =>'10', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check' => '', 'default' => '', 'text1' => '', 'text2' => 'gibt den hilfetext des subcommands aus'},
);
# parsen und generieren eines hashs (%optionsall) zum erzeugen von optionen (Getopt::Long)
foreach my $par (keys %OPTIONS_TABLE)
{
	if ( ${$OPTIONS_TABLE{$par}}{'maxoccur'} > 1 )
	{
		my @tmp;
		if (${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
		{
			$optionsall{$par} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "string")
		{
			$optionsall{$par . "=s"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "integer")
		{
			$optionsall{$par . "=i"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "float")
		{
			$optionsall{$par . "=f"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "file")
		{
			$optionsall{$par . "=s"} = \@tmp;
		}
		
		$OPT{$par} = \@tmp;
		$OPTHELP{$par} = {'text1' => ${$OPTIONS_TABLE{$par}}{'text1'}, 'text2' => ${$OPTIONS_TABLE{$par}}{'text2'}};
		if (${$OPTIONS_TABLE{$par}}{'minoccur'} > 0)
		{
			$OPTHELP{$par}{'mandatory'} = 1;
		}
		else
		{
			$OPTHELP{$par}{'mandatory'} = 0;
		}
		
		if (${$OPTIONS_TABLE{$par}}{'default'} =~ m/.+/)
		{
			$OPTHELP{$par}{'default'} = ${$OPTIONS_TABLE{$par}}{'default'};
		}
		else
		{
			$OPTHELP{$par}{'default'} = 0;
		}
	}
	else
	{
		my $tmp;
		if (${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
		{
			$optionsall{$par} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "string")
		{
			$optionsall{$par . "=s"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "integer")
		{
			$optionsall{$par . "=i"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "float")
		{
			$optionsall{$par . "=f"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "file")
		{
			$optionsall{$par . "=s"} = \$tmp;
		}
		
		$OPT{$par} = \$tmp;
		$OPTHELP{$par} = {'text1' => ${$OPTIONS_TABLE{$par}}{'text1'}, 'text2' => ${$OPTIONS_TABLE{$par}}{'text2'}};
		if (${$OPTIONS_TABLE{$par}}{'minoccur'} > 0)
		{
			$OPTHELP{$par}{'mandatory'} = 1;
		}
		else
		{
			$OPTHELP{$par}{'mandatory'} = 0;
		}
		
		if (${$OPTIONS_TABLE{$par}}{'default'} =~ m/.+/)
		{
			$OPTHELP{$par}{'default'} = ${$OPTIONS_TABLE{$par}}{'default'};
		}
		else
		{
			$OPTHELP{$par}{'default'} = 0;
		}
	}
}
# das tatsaechliche erzeugen der options mit Getopt::Long

my $result = GetOptions(%optionsall);
unless($result)
{
	logit('warn', "problem occured while reading commandline options. information given with unknown options will be ignored. this could be a problem.");
#	exit(1);
}

# OPTIONEN DEFAULTS ZUWEISEN
foreach my $par (sort keys %OPTIONS_TABLE)
{
	# wenn eine option vom user nicht gesetzt wurde, aber dafuer ein default-wert existiert, soll dieser gesetzt werden
	
# wenn es ein SCALAR ist
	if (ref($OPT{$par}) eq "SCALAR")
	{
		if (!(${$OPT{$par}}) && ${$OPTIONS_TABLE{$par}}{'default'} && ${$OPTIONS_TABLE{$par}}{'default'} ne "")
		{
			if(${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
			{
				logit('info', 'setting flag --' . $par);
			}
			else
			{
				logit('info', 'setting default for --' . $par . '=' . ${$OPTIONS_TABLE{$par}}{'default'} );
			}
			my @tmp_defaults = split ("%%", ${$OPTIONS_TABLE{$par}}{'default'});
			${$OPT{$par}} = $tmp_defaults[0];
		}
	}
	
	elsif (ref($OPT{$par}) eq "ARRAY")
	{
		if (!(${$OPT{$par}}[0]) && ${$OPTIONS_TABLE{$par}}{'default'} && ${$OPTIONS_TABLE{$par}}{'default'} ne "")
		{
			logit('info', 'setting default for --' . $par . '=' . ${$OPTIONS_TABLE{$par}}{'default'} );
			@{$OPT{$par}} = split ("%%", ${$OPTIONS_TABLE{$par}}{'default'});
		}
	}
	
}
#----------------------------------------------------------------------------
# processcraft:options:end
#============================================================================
#============================================================================
# processcraft:config:begin:auto:109449155366948360484231969047451381854
#----------------------------------------------------------------------------
my %CONF;
if (stat $conf_path)
{
	my %CONF_ORG = &getvars($conf_path);
# viele parameter im parameterfile enthalten pfade relativ zum installationsverzeichnis
# diese pfade sollen auf absolute pfade expandiert werden
	logit("info", "expanding config parameter to absolute path");
	foreach my $param (sort keys %CONF_ORG)
	{
# gibts da ein file? Ja? Dann soll auf den absoluten Pfad expandiert werden
		if ((($CONF_ORG{$param} ne "") && (stat $bindir."/".$CONF_ORG{$param})))
		{
			$CONF{$param} = File::Spec->rel2abs($bindir."/".$CONF_ORG{$param});
			logit("info", "parameter $param (value=" . $CONF_ORG{$param} .") expanding to (new_value=".$CONF{$param}.")");
		}
		else
		{
			$CONF{$param} = $CONF_ORG{$param};
		}
	}
}
else
{
	logit("warn", "cannot read $conf_path. builtin config-read capabilities cannot be used");
}
#----------------------------------------------------------------------------
# processcraft:config:end
#============================================================================
#============================================================================
# processcraft:help:begin:auto:91753739880880427107698082071840062280
#----------------------------------------------------------------------------
my $helptext;

$helptext .= "usage: $filename <subcommand> PARAMETER\n";
$helptext .= "\n";
$helptext .= "possible subcommands: list, gui, checkin, checkout, progress, init, cleandb\n";
$helptext .= "\n";
$helptext .= "Parameter\n";

for(my $x=0; $x<11; $x++)
{
	foreach(sort keys %OPTHELP)
	{	
		if ( ${$OPTIONS_TABLE{$_}}{'reihenfolge'} == $x )
		{
			$helptext .= sprintf (" --%s%s", $_, ${$OPTHELP{$_}}{'text1'});
	
			if (${$OPTHELP{$_}}{'mandatory'})
			{
				$helptext .= " (mandatory";
			}
			else
			{
				$helptext .= " (optional";
			}
	
			# wenn der default==true und es sich um einen flag-parameter handelt
			if ( (${$OPTHELP{$_}}{'default'} eq "1") && (${$OPTIONS_TABLE{$_}}{'definition'} eq "flag") )
			{
				$helptext .= ", default: on)";
			}
			# wenn der default==false und es sich um einen flag-parameter handelt
			elsif ( (${$OPTHELP{$_}}{'default'} eq "0") && (${$OPTIONS_TABLE{$_}}{'definition'} eq "flag") )
			{
				$helptext .= ", default: off)";
			}
			# wenn es einen default gibt
			elsif (${$OPTHELP{$_}}{'default'})
			{
				$helptext .= ", default: " . ${$OPTHELP{$_}}{'default'} . ")";
			}
			else
			{
				$helptext .= ")";
			}
			$helptext .= "\n";
	
			# helptext nach ca. 66 Zeichen umbrechen
			${$OPTHELP{$_}}{'text2'} =~ s/(.{66}[^\s]*)\s+/$1\n/g;
	
			foreach(split ("\n", ${$OPTHELP{$_}}{'text2'}))
			{
				$helptext .= sprintf ("       %s\n",  $_);
			}
			$helptext .= "\n";
		}
	}
}
$helptext .= "author: alexander.vogel\@caegroup.de | version: $version | date: $date\n";
#----------------------------------------------------------------------------
# processcraft:help:end
#============================================================================
#============================================================================
# processcraft:calls:begin:auto:241142859987282060025963051819748651429
#----------------------------------------------------------------------------
if (${$OPT{'h'}})
{
	print STDERR $helptext;
	exit(0);
}
if (${$OPT{'doc'}})
{
	if (stat $doc_path)
	{
		logit('info', 'showing documentation');
		exec 'acroread ' . $doc_path;
	}
	else
	{
		logit('info', 'no documentation installed ('.$doc_path.')');
	}
	exit(0);
}
#----------------------------------------------------------------------------
# processcraft:calls:end
#============================================================================
#============================================================================
# processcraft:checks:begin:auto:161777879106571402057629813209326083860
#----------------------------------------------------------------------------
my $error_patternchecks = 0;
my $error_anzahl = 0;

# checken der anzahl der aufrufoptionen
foreach my $key (sort keys %OPT)
{
	my $anzahl = 0;
	if    ( (ref($OPT{$key}) eq "SCALAR") && ( defined(${$OPT{$key}}) ) ) {$anzahl = 1}
	elsif (ref($OPT{$key}) eq "ARRAY") {$anzahl = scalar(@{$OPT{$key}});}
	
	# minoccur checken
	if ( ${$OPTIONS_TABLE{$key}}{'minoccur'} > $anzahl )
	{
		if ( ${$OPTIONS_TABLE{$key}}{'minoccur'} == 1 && ${$OPTIONS_TABLE{$key}}{'maxoccur'} == 1)
		{
			logit('error', 'option --'.$key.' needed.');
		}
		elsif ( ${$OPTIONS_TABLE{$key}}{'minoccur'} < ${$OPTIONS_TABLE{$key}}{'maxoccur'})
		{
			logit('error', 'option --'.$key.' needed at least '.${$OPTIONS_TABLE{$key}}{'minoccur'}.' times.');
		}
		$error_anzahl++;
	}
	# maxoccur checken
	if ( ${$OPTIONS_TABLE{$key}}{'maxoccur'} < $anzahl )
	{
		logit('error', 'option --'.$key.' may only be used '.${$OPTIONS_TABLE{$key}}{'maxoccur'}.' times.');
		$error_anzahl++;
	}
}

# checken des inhalts der aufrufoptionen
foreach my $key (sort keys %OPT)
{
	my $anzahl = 0;
	if ( (ref($OPT{$key}) eq "SCALAR") && ( defined(${$OPT{$key}}) ) )
	{
		unless (${$OPT{$key}} =~ m/${$OPTIONS_TABLE{$key}}{'check'}/)
		{
			logit('error', 'option --'.$key.'='.${$OPT{$key}}.' does not match the expected pattern /'.${$OPTIONS_TABLE{$key}}{'check'}.'/.');
			$error_patternchecks++;
		}
	}
	
	elsif ( (ref($OPT{$key}) eq "ARRAY") && (scalar(@{$OPT{$key}})) )
	{
		foreach my $value (@{$OPT{$key}})
		{
			unless ($value =~ m/${$OPTIONS_TABLE{$key}}{'check'}/)
			{
				logit('error', 'option --'.$key.'='.$value.' does not match the expected pattern /'.${$OPTIONS_TABLE{$key}}{'check'}.'/.');
				$error_patternchecks++;
			}
		}
	}
}


if ($error_anzahl + $error_patternchecks)
{
	logit('fatal', $error_anzahl + $error_patternchecks .' error(s) found in call. call -h for help. exit.');
	exit(1);
}
#----------------------------------------------------------------------------
# processcraft:checks:end
#============================================================================
#============================================================================
# processcraft:business:begin:auto:216836334144011758316111106533555963187
#----------------------------------------------------------------------------
#
# you may use getConfig(<string>), setConfig(<string>) to deal with data from the configfile if one exists.
# you may use getOption(<string>), setOption(<string>) and addOption(<string>) to deal with data from the call-options.
#
# place your business logic here.
#
my $subcommand = "gui";
if(@ARGV)
{
	if($ARGV[0] !~ m/^-/)
	{
		if(getConfig($ARGV[0]))
		{
			$subcommand = shift @ARGV;
		}
	}
}

unless($subcommand)
{
	logit("fatal", "no subcommand. try -help for help.");
	exit(1);
}

# jedes argument in " packen
my @ARGV_IN_ANFUEHRUNGSZEICHEN;
foreach my $arg (@ARGV)
{
	push(@ARGV_IN_ANFUEHRUNGSZEICHEN, "\"" . $arg . "\"");
}

my $return = 0;
if (getOption("hh"))
{
	my $call = getConfig($subcommand) . " @ARGV_IN_ANFUEHRUNGSZEICHEN --help";
	logit("info", "launching $subcommand: $call");
	$return = system($call);
}
else
{
	my $call = getConfig($subcommand) . " @ARGV_IN_ANFUEHRUNGSZEICHEN";
	logit("info", "launching $subcommand: $call");
	$return = system($call);
}

if ($return)
{
	logit("fatal", "problems with launching subcommand " . $subcommand);
	exit(1);
}
#----------------------------------------------------------------------------
# processcraft:business:end
#============================================================================
#============================================================================
# processcraft:subs:begin:auto:165563843402253036507497644898354056126
#----------------------------------------------------------------------------
sub getvars
{
    my $fp_conf = shift;

    my %CONF;
    if (!open (CONF, "<$fp_conf")) {die "cannot read $fp_conf $!\n";}
    
    while(<CONF>)
    {
        if    ( $_ =~ m/^#/) {next}
        elsif ( $_ =~ m/^$/) {next}
		elsif ( $_ =~ m/^\s*$/) {next}
        else
        {
            my @tmp = split('=', $_);
            
        	# falls unwahr, soll der parameter einen leeren string erhalten
        	unless ($tmp[1]) {$tmp[1] = '';}
        	
        	$tmp[0] =~ s/\s$//g;
        	$tmp[0] =~ s/^\s//g;
        	$tmp[1] =~ s/\s$//g;
        	$tmp[1] =~ s/^\s//g;
        			
            $CONF{$tmp[0]} = $tmp[1];
        }
    }
    return %CONF;
}
sub logit
{
	if (scalar(@_) < 2) {die "wrong call on subroutine 'logit'";}
	my $level = shift;
	my $msg = shift;
	my $dest;
	if (@_)
	{
		$dest = shift;
	}
	
	my $timestamp = localtime(time);
	
	my $ausgabestring = '[' . $timestamp . ']:' . $level . ':' . $msg; 
	
	if (!($dest))
	{
		if (defined ${$OPT{'log'}})
		{
			system "echo \"$ausgabestring\" >> ${$OPT{'log'}}";
		}
		else
		{
			print STDERR $ausgabestring."\n";
		}
	}
	elsif ($dest =~ m/^stderr$/i)
	{
		print STDERR $ausgabestring."\n";
	}
	elsif ($dest =~ m/^stdout$/i)
	{
		print STDOUT $ausgabestring."\n";
	}
	elsif (($dest) && (stat $dest))
	{
		system 'echo $ausgabestring >> $dest';
	}
	else
	{
		print STDERR 'unknown logging destination $dest (file does not exist)' . '. assuming stderr';
		print STDERR $ausgabestring."\n";
	}
}

sub getOption
{
	my $key = shift;
	
	# wenn option nicht existiert oder die anzahl der values innerhalb der option = 0 ist
	if (!(defined $OPT{$key}))
	{
		return undef;
	}
	
	elsif (ref($OPT{$key}) eq "SCALAR")
	{
		if (!defined ${$OPT{$key}})
		{
			return undef;
		}
		else
		{
			return ${$OPT{$key}}
		}
	}
	
	elsif (ref($OPT{$key}) eq "ARRAY")
	{
		if ( (! @{$OPT{$key}}) || (scalar @{$OPT{$key}} == 0) )
		{
			return undef;
		}
		# wenn es genau eine value fuer die option gibt 
		elsif (scalar(@{$OPT{$key}}) == 1)
		{
			return ${$OPT{$key}}[0]
		}
		# wenn es mehrere values fuer die option gibt
		else
		{
			return @{$OPT{$key}}
		}
	}
}

sub setOption
{
	my $key = shift;
	
	if (ref($OPT{$key}) eq "SCALAR")
	{
		if (@_ > 1)
		{
			&logit("error", "cannot apply a list (@_) to a scalar option ($key).");
		}
		
		else
		{
			${$OPT{$key}} = $_[0];
		}
	}
	
	elsif (ref($OPT{$key}) eq "ARRAY")
	{
		@{$OPT{$key}} = @_;
	}
}

sub addOption
{
	my $key = shift;
	
	if (ref($OPT{$key}) eq "ARRAY")
	{
		push @{$OPT{$key}}, @_;
	}
}

sub getConfig
{
	my $key = shift;
	if (defined $CONF{$key})
	{
		return $CONF{$key};
	}
}

sub setConfig
{
	my $key = shift;
	my $value = shift;
	
	$CONF{$key} = $value;
}

#----------------------------------------------------------------------------
# processcraft:subs:end
#============================================================================
