#!/usr/bin/perl
#============================================================================
# processcraft:meta:begin:auto:128439723220832314378353338858216584079
#----------------------------------------------------------------------------
# generated by codegen-core on 2014-04-11 16:05:15.23
my $version = "[% version %]";
my $date = "[% date %]";
#----------------------------------------------------------------------------
# processcraft:meta:end
#============================================================================
#============================================================================
# processcraft:modules:begin:auto:330248501553469149173865939754177189603
#----------------------------------------------------------------------------
use warnings;
use strict;
use Getopt::Long;
Getopt::Long::Configure("pass_through");
use File::Spec;
use File::Copy;
use Cwd;
use Time::HiRes qw(gettimeofday);
#----------------------------------------------------------------------------
# processcraft:modules:end
#============================================================================
#============================================================================
# processcraft:path:begin:auto:68381984935848211475862083321312588448
#----------------------------------------------------------------------------
# feststellen des installationsortes des scripts
my ($filename, $directories, $suffix);
BEGIN
{
    use File::Basename;
    ($filename, $directories, $suffix) = fileparse ($0);
}

# autoflush
$|=1;

# feststellen des installationsortes des programmes
$directories = File::Spec->rel2abs($directories);
my $installdir = $directories . "/..";
my $etcdir = $installdir . "/etc";
my $docdir = $installdir . "/doc";
my $bindir = $directories;

# einbinden der avoge module
# zuerst, falls aus installationsverzeichnis gesucht wird
use lib $directories . "../../../myperllib/master/lib";
# falls aus eclipse gesucht wird
use lib $directories . "../../myperllib/lib";
# falls aus installationsverzeichnis das eigene lib gesucht wird (wird benoetigt falls die zentrale version nicht mehr passt)
use lib $directories . "../myperllib/lib";
# falls aus installationsverzeichnis cb2-scripts
use lib $directories . "../../../../cb2common/lib/1.0";
# falls aus installationsverzeichnis gesucht wird zuerst das lokale lib verwenden
use lib $directories . "../lib";

# path to configurationfile
my $conf_path1 = $directories . "/" . $filename.".conf";
my $conf_path2 = $etcdir . "/" . $filename.".conf";
# path to documentation
my $doc_path = $docdir . "/" . $filename.".pdf";
#----------------------------------------------------------------------------
# processcraft:path:end
#============================================================================
#============================================================================
# processcraft:options:begin:auto:253496301568349124646742201071137822736
#----------------------------------------------------------------------------
my %OPT;
my %OPTHELP;
my %optionsall;
# defaultoptions
# hier koenne alle 'festen' optionen definiert werden
my %OPTIONS_TABLE = (
# 1 < reihenfolge <= 15
# definition der standardoptions
				'h' => {'reihenfolge' => '9', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'', 'default' => '', 'text1' => '', 'text2' => 'prints this helptext'},
				'log'  => {'reihenfolge' => '7', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'string', 'check'=>'', 'default' => '', 'text1' => '=FILE', 'text2' => 'logs in a file instead of STDERR'},
				'd'  => {'reihenfolge' => '11', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'', 'default' => '', 'text1' => '', 'text2' => 'will also log debug-statements.'},

# definition der standardoptions
				'hh' => {'reihenfolge' =>'10', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check' => '', 'default' => '', 'text1' => '', 'text2' => 'gibt den hilfetext des subcommands aus'},
);
# dynamische standardoptions definieren
# wenn kein dokufile vorhanden ist, wird auch diese option nicht angelegt
if (stat $doc_path)
{
	$OPTIONS_TABLE{'doc'} = {'reihenfolge' => '9', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'', 'default' => '', 'text1' => '', 'text2' => "shows documentation
(".Cwd::realpath(File::Spec->rel2abs($doc_path)).")"};
}
# wenn kein config-file vorhanden ist, wird auch diese option nicht angelegt
if (stat $conf_path1)
{
	my %CONF_TMP = &getvars($conf_path1);
	$OPTIONS_TABLE{'conf'} = {'reihenfolge' => '10', 'minoccur' => '0', 'maxoccur' => '99', 'definition' => 'string', 'check'=>'^[^=]+=[^=]+$', 'default' => '', 'text1' => '=KEY=VALUE', 'text2' => 'for redefinition of configuration variables (instead of using the ones in BLA '.Cwd::realpath(File::Spec->rel2abs($conf_path1)).'). (possible KEYs are: ' . join(", ", sort keys %CONF_TMP) . ')'};
}
elsif (stat $conf_path2)
{
	my %CONF_TMP = &getvars($conf_path2);
	$OPTIONS_TABLE{'conf'} = {'reihenfolge' => '10', 'minoccur' => '0', 'maxoccur' => '99', 'definition' => 'string', 'check'=>'^[^=]+=[^=]+$', 'default' => '', 'text1' => '=KEY=VALUE', 'text2' => 'for redefinition of configuration variables (instead of using the ones in '.Cwd::realpath(File::Spec->rel2abs($conf_path2)).'). (possible KEYs are: ' . join(", ", sort keys %CONF_TMP) . ')'};
}
# parsen und generieren eines hashs (%optionsall) zum erzeugen von optionen (Getopt::Long)
foreach my $par (keys %OPTIONS_TABLE)
{
	if ( ${$OPTIONS_TABLE{$par}}{'maxoccur'} > 1 )
	{
		my @tmp;
		if (${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
		{
			$optionsall{$par} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "string")
		{
			$optionsall{$par . "=s"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "integer")
		{
			$optionsall{$par . "=i"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "float")
		{
			$optionsall{$par . "=f"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "file")
		{
			$optionsall{$par . "=s"} = \@tmp;
		}
		
		$OPT{$par} = \@tmp;
		$OPTHELP{$par} = {'text1' => ${$OPTIONS_TABLE{$par}}{'text1'}, 'text2' => ${$OPTIONS_TABLE{$par}}{'text2'}};
		if (${$OPTIONS_TABLE{$par}}{'minoccur'} > 0)
		{
			$OPTHELP{$par}{'mandatory'} = 1;
		}
		else
		{
			$OPTHELP{$par}{'mandatory'} = 0;
		}
		
		if (${$OPTIONS_TABLE{$par}}{'default'} =~ m/.+/)
		{
			$OPTHELP{$par}{'default'} = ${$OPTIONS_TABLE{$par}}{'default'};
		}
		else
		{
			$OPTHELP{$par}{'default'} = 0;
		}
	}
	else
	{
		my $tmp;
		if (${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
		{
			$optionsall{$par} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "string")
		{
			$optionsall{$par . "=s"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "integer")
		{
			$optionsall{$par . "=i"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "float")
		{
			$optionsall{$par . "=f"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "file")
		{
			$optionsall{$par . "=s"} = \$tmp;
		}
		
		$OPT{$par} = \$tmp;
		$OPTHELP{$par} = {'text1' => ${$OPTIONS_TABLE{$par}}{'text1'}, 'text2' => ${$OPTIONS_TABLE{$par}}{'text2'}};
		if (${$OPTIONS_TABLE{$par}}{'minoccur'} > 0)
		{
			$OPTHELP{$par}{'mandatory'} = 1;
		}
		else
		{
			$OPTHELP{$par}{'mandatory'} = 0;
		}
		
		if (${$OPTIONS_TABLE{$par}}{'default'} =~ m/.+/)
		{
			$OPTHELP{$par}{'default'} = ${$OPTIONS_TABLE{$par}}{'default'};
		}
		else
		{
			$OPTHELP{$par}{'default'} = 0;
		}
	}
}
# das tatsaechliche erzeugen der options mit Getopt::Long

my $result = GetOptions(%optionsall);
unless($result)
{
	logit('warn', 'problem occured while reading commandline options. information given with unknown options will be ignored. this could be a problem.');
#	exit(1);
}

# OPTIONEN DEFAULTS ZUWEISEN
foreach my $par (sort keys %OPTIONS_TABLE)
{
	# wenn eine option vom user nicht gesetzt wurde, aber dafuer ein default-wert existiert, soll dieser gesetzt werden
	
# wenn es ein SCALAR ist
	if (ref($OPT{$par}) eq "SCALAR")
	{
		if (!(${$OPT{$par}}) && ${$OPTIONS_TABLE{$par}}{'default'} && ${$OPTIONS_TABLE{$par}}{'default'} ne "")
		{
			if(${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
			{
				logit('info', 'setting flag --' . $par);
			}
			else
			{
				logit('info', 'setting default for --' . $par . '=' . ${$OPTIONS_TABLE{$par}}{'default'} );
			}
			my @tmp_defaults = split ("%%", ${$OPTIONS_TABLE{$par}}{'default'});
			${$OPT{$par}} = $tmp_defaults[0];
		}
	}
	
	elsif (ref($OPT{$par}) eq "ARRAY")
	{
		if (!(${$OPT{$par}}[0]) && ${$OPTIONS_TABLE{$par}}{'default'} && ${$OPTIONS_TABLE{$par}}{'default'} ne "")
		{
			logit('info', 'setting default for --' . $par . '=' . ${$OPTIONS_TABLE{$par}}{'default'} );
			@{$OPT{$par}} = split ("%%", ${$OPTIONS_TABLE{$par}}{'default'});
		}
	}
	
}
#----------------------------------------------------------------------------
# processcraft:options:end
#============================================================================
#============================================================================
# processcraft:config:begin:auto:8500070240352151188420394503474922399
#----------------------------------------------------------------------------
my %CONF;
my %CONF_ORG;

# einlesen des config-files
if (stat $conf_path1)
{
	logit("debug", "config-file found: $conf_path1");
	%CONF_ORG = &getvars($conf_path1);
}
elsif (stat $conf_path2)
{
	logit("debug", "config-file found: $conf_path2");
	%CONF_ORG = &getvars($conf_path2);
}
else
{
	logit("debug", "no config found in both possible locations (location1: $conf_path1) (location2: $conf_path2). builtin config-read capabilities cannot be used");
}

# setzen der vom user uebergebenen configparameter und damit ueberschreiben der bestehenden mit dem gleichen namen
if (&getOption("conf"))
{
	foreach my $conf (&getOption("conf"))
	{
		my @param = split("=", $conf);
		logit("info", "user-driven reconfiguration of " . $conf);
		if (exists $CONF_ORG{$param[0]})
		{
			logit("warn", "reconfiguring parameter (" . $param[0] . "=" . $CONF_ORG{$param[0]} . ") with user value (" . $param[0] . "=" . $param[1] . ")");
			$CONF_ORG{$param[0]} = $param[1];
		}
		else
		{
			logit("fatal", "user config parameter does not exist in configfile (" . $param[0] . ") - ignoring.");
			logit("info", "you only may use these keys as a configuration parameter: " . join (", ", keys %CONF_ORG));
			exit(1);
		}
	}
}

# viele parameter im parameterfile enthalten pfade relativ zum installationsverzeichnis
# diese pfade sollen auf absolute pfade expandiert werden
logit("debug", "expanding config parameter to absolute path");
foreach my $param (sort keys %CONF_ORG)
{
# gibts da ein file? Ja? Dann soll auf den absoluten Pfad expandiert werden
	if ((($CONF_ORG{$param} ne "") && (stat $bindir."/".$CONF_ORG{$param})))
	{
		$CONF{$param} = File::Spec->rel2abs($bindir."/".$CONF_ORG{$param});
		logit("debug", "parameter $param (value=" . $CONF_ORG{$param} .") expanding to (new_value=".$CONF{$param}.")");
	}
	else
	{
		$CONF{$param} = $CONF_ORG{$param};
	}
}
#----------------------------------------------------------------------------
# processcraft:config:end
#============================================================================
#============================================================================
# processcraft:help:begin:auto:252032364884595945376193847609763870669
#----------------------------------------------------------------------------
my $helptext;

$helptext .= "usage: $filename <subcommand> PARAMETER\n";
$helptext .= "\n";
$helptext .= "possible subcommands: " . join(", ", getConfigKeys()) . "\n";
$helptext .= "\n";
$helptext .= "Parameter\n";

for(my $x=0; $x<15; $x++)
{
	foreach(sort keys %OPTHELP)
	{	
		if ( ${$OPTIONS_TABLE{$_}}{'reihenfolge'} == $x )
		{
			$helptext .= sprintf (" --%s%s", $_, ${$OPTHELP{$_}}{'text1'});
	
			if (${$OPTHELP{$_}}{'mandatory'})
			{
				$helptext .= " (mandatory";
			}
			else
			{
				$helptext .= " (optional";
			}
	
			# wenn der default==true und es sich um einen flag-parameter handelt
			if ( (${$OPTHELP{$_}}{'default'} eq "1") && (${$OPTIONS_TABLE{$_}}{'definition'} eq "flag") )
			{
				$helptext .= ", default: on)";
			}
			# wenn der default==false und es sich um einen flag-parameter handelt
			elsif ( (${$OPTHELP{$_}}{'default'} eq "0") && (${$OPTIONS_TABLE{$_}}{'definition'} eq "flag") )
			{
				$helptext .= ", default: off)";
			}
			# wenn es einen default gibt
			elsif (${$OPTHELP{$_}}{'default'})
			{
				$helptext .= ", default: " . ${$OPTHELP{$_}}{'default'} . ")";
			}
			else
			{
				$helptext .= ")";
			}
			$helptext .= "\n";
	
			# helptext nach ca. 66 Zeichen umbrechen
			${$OPTHELP{$_}}{'text2'} =~ s/(.{66}[^\s]*)\s+/$1\n/g;
	
			foreach(split ("\n", ${$OPTHELP{$_}}{'text2'}))
			{
				$helptext .= sprintf ("       %s\n",  $_);
			}
			$helptext .= "\n";
		}
	}
}
$helptext .= "author: info\@prozesskraft.de | version: $version | date: $date\n\n";

$helptext .= "installdir: " . Cwd::realpath(File::Spec->rel2abs($0)) . "\n";
#----------------------------------------------------------------------------
# processcraft:help:end
#============================================================================
#============================================================================
# processcraft:calls:begin:auto:286133771702116587700809355193997334619
#----------------------------------------------------------------------------
if (getOption("h"))
{
	print STDERR $helptext;
	exit(0);
}
if (getOption("doc"))
{
	if (stat $doc_path)
	{
		logit('info', 'showing documentation');
		exec 'acroread ' . $doc_path;
	}
	else
	{
		logit('info', 'no documentation installed ('.$doc_path.')');
	}
	exit(0);
}
#----------------------------------------------------------------------------
# processcraft:calls:end
#============================================================================
#============================================================================
# processcraft:checks:begin:auto:161777879106571402057629813209326083860
#----------------------------------------------------------------------------
my $error_patternchecks = 0;
my $error_anzahl = 0;

# checken der anzahl der aufrufoptionen
foreach my $key (sort keys %OPT)
{
	my $anzahl = 0;
	if    ( (ref($OPT{$key}) eq "SCALAR") && ( defined(${$OPT{$key}}) ) ) {$anzahl = 1}
	elsif (ref($OPT{$key}) eq "ARRAY") {$anzahl = scalar(@{$OPT{$key}});}
	
	# minoccur checken
	if ( ${$OPTIONS_TABLE{$key}}{'minoccur'} > $anzahl )
	{
		if ( ${$OPTIONS_TABLE{$key}}{'minoccur'} == 1 && ${$OPTIONS_TABLE{$key}}{'maxoccur'} == 1)
		{
			logit('error', 'option --'.$key.' needed.');
		}
		elsif ( ${$OPTIONS_TABLE{$key}}{'minoccur'} < ${$OPTIONS_TABLE{$key}}{'maxoccur'})
		{
			logit('error', 'option --'.$key.' needed at least '.${$OPTIONS_TABLE{$key}}{'minoccur'}.' times.');
		}
		$error_anzahl++;
	}
	# maxoccur checken
	if ( ${$OPTIONS_TABLE{$key}}{'maxoccur'} < $anzahl )
	{
		logit('error', 'option --'.$key.' may only be used '.${$OPTIONS_TABLE{$key}}{'maxoccur'}.' times.');
		$error_anzahl++;
	}
}

# checken des inhalts der aufrufoptionen
foreach my $key (sort keys %OPT)
{
	my $anzahl = 0;
	if ( (ref($OPT{$key}) eq "SCALAR") && ( defined(${$OPT{$key}}) ) )
	{
		unless (${$OPT{$key}} =~ m/${$OPTIONS_TABLE{$key}}{'check'}/)
		{
			logit('error', 'option --'.$key.'='.${$OPT{$key}}.' does not match the expected pattern /'.${$OPTIONS_TABLE{$key}}{'check'}.'/.');
			$error_patternchecks++;
		}
	}
	
	elsif ( (ref($OPT{$key}) eq "ARRAY") && (scalar(@{$OPT{$key}})) )
	{
		foreach my $value (@{$OPT{$key}})
		{
			unless ($value =~ m/${$OPTIONS_TABLE{$key}}{'check'}/)
			{
				logit('error', 'option --'.$key.'='.$value.' does not match the expected pattern /'.${$OPTIONS_TABLE{$key}}{'check'}.'/.');
				$error_patternchecks++;
			}
		}
	}
}


if ($error_anzahl + $error_patternchecks)
{
	logit('fatal', $error_anzahl + $error_patternchecks .' error(s) found in call. call -h for help. exit.');
	exit(1);
}
#----------------------------------------------------------------------------
# processcraft:checks:end
#============================================================================
#============================================================================
# processcraft:business:begin:auto:100462516961661552749797468825441321916
#----------------------------------------------------------------------------
#
# you may use getConfig(<key>), setConfig(<key>, <value>), getConfigKeys() to deal with data from the configfile if one exists.
# you may use getOption(<key>), setOption(<string>, <value>), getOptionKeys(), and addOption(<string>, <key>) to deal with data from the call-options.
# you may use @ARG for all unknown/unparsed options given. this makes writing wrapperscripts easier.
#
# place your business logic here.
#
my $subcommand = "gui";
if(@ARGV)
{
	if($ARGV[0] !~ m/^-/)
	{
		if(getConfig($ARGV[0]))
		{
			$subcommand = shift @ARGV;
		}
	}
}

#-------------------
# wenn das programm nicht verfuegbar ist - entsprechende loggingausgabe
my @subcommand = split(" ", getConfig($subcommand));
unless(stat $subcommand[0])
{
	&logit("error", "target for call pradar is not available: $subcommand[0] (part of " . getConfig($subcommand) . ")");
	exit(1);
}

my $return = 0;
if (getOption("hh"))
{
	my $call = getConfig($subcommand) . " @ARGV --help";
	logit("info", "launching $subcommand: $call");
	$return = system($call);
}
else
{
	my $call = getConfig($subcommand) . " @ARGV";
	logit("info", "launching $subcommand: $call");
	$return = system($call);
}

#
#----------------------------------------------------------------------------
# processcraft:business:end
#============================================================================
#============================================================================
# processcraft:subs:begin:auto:6788701245856146428780031910504568886
#----------------------------------------------------------------------------
sub getvars
{
    my $fp_conf = shift;

    my %CONF;
    if (!open (CONF, "<$fp_conf")) {die "cannot read $fp_conf $!\n";}
    
    while(<CONF>)
    {
        if    ( $_ =~ m/^#/) {next}
        elsif ( $_ =~ m/^$/) {next}
		elsif ( $_ =~ m/^\s*$/) {next}
        else
        {
            my @tmp = split('=', $_);
            
        	# falls unwahr, soll der parameter einen leeren string erhalten
        	unless ($tmp[1]) {$tmp[1] = '';}
        	
        	$tmp[0] =~ s/\s$//g;
        	$tmp[0] =~ s/^\s//g;
        	$tmp[1] =~ s/\s$//g;
        	$tmp[1] =~ s/^\s//g;
        			
            $CONF{$tmp[0]} = $tmp[1];
        }
    }
    close CONF;
    return %CONF;
}
sub logit
{
	if (scalar(@_) < 2) {die "wrong call on subroutine 'logit'";}
	my $level = shift;
	my $msg = shift;
	my $dest;
	if (@_)
	{
		$dest = shift;
	}
	
# wenn loglevel == debug, ABER --debug nicht gesetzt wurde, soll nicht geloggt werden
		if ( ($level eq "debug") &! getOption("debug") )
		{
			return;
		}

	my $timestamp = localtime(time);
	
	my $ausgabestring = '[' . $timestamp . ']:' . $level . ':' . $msg; 
	
	if (!($dest))
	{
		my $logfile = &getOption("log");
		if ($logfile)
		{
			system "echo \"$ausgabestring\" >> $logfile";
		}
		else
		{
			print STDERR $ausgabestring."\n";
		}
	}
	elsif ($dest =~ m/^stderr$/i)
	{
		print STDERR $ausgabestring."\n";
	}
	elsif ($dest =~ m/^stdout$/i)
	{
		print STDOUT $ausgabestring."\n";
	}
	elsif (($dest) && (stat $dest))
	{
		system 'echo $ausgabestring >> $dest';
	}
	else
	{
		print STDERR 'unknown logging destination $dest (file does not exist)' . '. assuming stderr';
		print STDERR $ausgabestring."\n";
	}
}

sub getOptionKeys
{
	return sort keys %OPT;
}

sub getOption
{
	my $key = shift;
	
	# wenn option nicht existiert oder die anzahl der values innerhalb der option = 0 ist
	if (!(defined $OPT{$key}))
	{
		return undef;
	}
	
	elsif (ref($OPT{$key}) eq "SCALAR")
	{
		if (!defined ${$OPT{$key}})
		{
			return undef;
		}
		else
		{
			return ${$OPT{$key}}
		}
	}
	
	elsif (ref($OPT{$key}) eq "ARRAY")
	{
		if ( (! @{$OPT{$key}}) || (scalar @{$OPT{$key}} == 0) )
		{
			return undef;
		}
		# wenn es genau eine value fuer die option gibt 
		elsif (scalar(@{$OPT{$key}}) == 1)
		{
			return ${$OPT{$key}}[0]
		}
		# wenn es mehrere values fuer die option gibt
		else
		{
			return @{$OPT{$key}}
		}
	}
}

sub setOption
{
	my $key = shift;
	
	if (ref($OPT{$key}) eq "SCALAR")
	{
		if (@_ > 1)
		{
			&logit("error", "cannot apply a list (@_) to a scalar option ($key).");
		}
		
		else
		{
			${$OPT{$key}} = $_[0];
		}
	}
	
	elsif (ref($OPT{$key}) eq "ARRAY")
	{
		@{$OPT{$key}} = @_;
	}
}

sub addOption
{
	my $key = shift;
	
	if (ref($OPT{$key}) eq "ARRAY")
	{
		push @{$OPT{$key}}, @_;
	}
}

sub getConfigKeys
{
	return sort keys %CONF;
}

sub getConfig
{
	my $key = shift;
	if (defined $CONF{$key})
	{
		return $CONF{$key};
	}
}

sub setConfig
{
	my $key = shift;
	my $value = shift;
	
	$CONF{$key} = $value;
}

sub getTypedOptions
{

	my $type = shift;
	
	my %VARIABLE;
	my %FILE;

	logit("debug", "##### START identifing whether given options are a " . uc($type) . " #####");
	
	unless( $type =~ m/variable|file/ )
	{
		logit("fatal", "unknown type $type. only permitted one of these: variable, file, all");
		exit(1);
	}
	
	foreach my $option (getOptionKeys())
	{
	
		my @allValuesOfACertainOption;
		if(getOption($option))
		{
			@allValuesOfACertainOption = getOption($option);
		}
	
		my $isFile = 1;	#erst mal 'true'
		foreach my $actValue (@allValuesOfACertainOption)
		{
			unless (stat $actValue) {$isFile = 0;}
		}
	
		if(scalar(@allValuesOfACertainOption))
		{
#			logit("debug", "option --" . $option . " exists");

			if($isFile && $type =~ m/file/i)
			{
		
				logit("debug", "option --" . $option." is identified as a FILE-option");
				foreach (@allValuesOfACertainOption)
				{
					logit("debug", "memorizing as FILE: $option->$_");
					push(@{$FILE{'root'}}, [$option, $_]);
				}
			}
			elsif($type =~ m/variable/i)
			{
				logit("debug", "option --" . $option." is identified as a VARIABLE-option");
				foreach (@allValuesOfACertainOption)
				{
					logit("debug", "memorizing as VARIABLE: $option->$_");
					push(@{$VARIABLE{'root'}}, [$option, $_]);
				}
			}
		}
	}
	
# falls keine eintraege in root existieren, soll eine leere annonyme liste angelegt werden
unless($FILE{'root'}) {$FILE{'root'} = [];}
unless($VARIABLE{'root'}) {$VARIABLE{'root'} = [];}

	logit("debug", "##### END   identifing whether given options are a " . uc($type) . " #####");
	if ($type =~ /file/i) {return %FILE;}
	elsif ($type =~ /variable/i) {return %VARIABLE;}

}

sub addFilesEtc
{
	my $refh_FILE = shift;
	
	# filesliste des etc-directories ermitteln
	opendir(ETC, $etcdir);
	my @fileOfEtc = grep{ $_ !~ m/^\./ } readdir(ETC);
	
	&logit("debug", "adding " . scalar(@fileOfEtc) . " files from <installdir>/etc to list 'installetc' of step 'root'");
	
	foreach my $fileOfEtc (@fileOfEtc)
	{
		push(@{$$refh_FILE{'root'}}, ["subdiretc", File::Spec->rel2abs($etcdir . "/" . $fileOfEtc)]);
		&logit("debug", "adding to 'root': subdiretc=" . File::Spec->rel2abs($etcdir . "/" . $fileOfEtc));
	}
}


sub expandPathInOptions
{
	foreach my $key (getOptionKeys())
	{
		if (ref($OPT{$key}) eq "SCALAR")
		{
			if ((${$OPT{$key}}) && (stat ${$OPT{$key}}))
			{
				&logit("info", "expanding path of the value of option $key");
				&logit("info", ${$OPT{$key}} . " -> " . File::Spec->rel2abs(${$OPT{$key}}));
				${$OPT{$key}} = File::Spec->rel2abs(${$OPT{$key}});
			}
		}
		
		elsif (ref($OPT{$key}) eq "ARRAY")
		{
			for(my $x=0; $x<scalar(@{$OPT{$key}}); $x++)
			{
				if ((${$OPT{$key}}[$x]) && (stat ${$OPT{$key}}[$x]) )
				{
					&logit("info", "expanding path of value of option $key");
					&logit("info", ${$OPT{$key}}[$x] . " -> " . File::Spec->rel2abs(${$OPT{$key}}[$x]));
					${$OPT{$key}}[$x] = File::Spec->rel2abs(${$OPT{$key}}[$x]);
				}
			}
		}
	}
}
#----------------------------------------------------------------------------
# processcraft:subs:end
#============================================================================
