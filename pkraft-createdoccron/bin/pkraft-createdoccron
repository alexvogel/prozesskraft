#!/usr/bin/perl
#============================================================================
# prozesskraft:meta:begin:auto:211431719290776189856127946418504014522
#----------------------------------------------------------------------------
# generated by codegen-core at 2015-07-22 15:45:02.101
# a tool from prozesskraft
my $procname = "[% procname %]";
my $version = "[% version %]";
my $date = "[% date %]";
#----------------------------------------------------------------------------
# prozesskraft:meta:end
#============================================================================
#============================================================================
# prozesskraft:modules:begin:auto:330248501553469149173865939754177189603
#----------------------------------------------------------------------------
use warnings;
use strict;
use Getopt::Long;
Getopt::Long::Configure("pass_through");
use File::Spec;
use File::Copy;
use Cwd;
use Time::HiRes qw(gettimeofday);
#----------------------------------------------------------------------------
# prozesskraft:modules:end
#============================================================================
#============================================================================
# prozesskraft:path:begin:auto:117886228267692765631040564024126683256
#----------------------------------------------------------------------------
my $FULLCALL = join(' ', $0, @ARGV);
# feststellen des installationsortes des scripts
my ($filename, $directories, $suffix);
BEGIN
{
    use File::Basename;
    ($filename, $directories, $suffix) = fileparse ($0);
}

# autoflush
$|=1;

# feststellen des installationsortes des programmes
my $installdir = File::Spec->rel2abs($directories);
my $etcdir = $installdir . "/../etc";
my $docdir = $installdir . "/../doc";
my $bindir = $directories;

# einbinden der avoge module
# zuerst, falls aus installationsverzeichnis gesucht wird
use lib $directories . "../../../myperllib/master/lib";
# falls aus eclipse gesucht wird
use lib $directories . "../../myperllib/lib";
# falls aus installationsverzeichnis das eigene lib gesucht wird (wird benoetigt falls die zentrale version nicht mehr passt)
use lib $directories . "../myperllib/lib";
# falls aus installationsverzeichnis cb2-scripts
use lib $directories . "../../../../cb2common/lib/1.0";
# falls aus installationsverzeichnis gesucht wird zuerst das lokale lib verwenden
use lib $directories . "../lib";

# path to configurationfile
my $conf_path1 = $directories . "/" . $filename.".conf";
my $conf_path2 = $etcdir . "/" . $filename.".conf";

my $baseFilename = $filename;
$baseFilename =~ s/\..+$//; # entfernen der extension
my $conf_path3 = $etcdir . "/" . $baseFilename.".conf";

# path to documentation
my $doc_path = $docdir . "/" . $filename.".pdf";

# das aufrufverzeichnis (basedir)
my $_basedir = cwd();
#----------------------------------------------------------------------------
# prozesskraft:path:end
#============================================================================
#============================================================================
# prozesskraft:options:begin:auto:26774767486000293171233959622917227506
#----------------------------------------------------------------------------
my %OPT;
my %OPTHELP;
my %optionsall;
# defaultoptions
# hier koenne alle 'festen' optionen definiert werden
my %OPTIONS_TABLE = (
# 1 < reihenfolge <= 15
# definition der standardoptions
				'help' => {'reihenfolge' => '13', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'1', 'default' => '', 'allowIntegratedListIfMultiOption' => 'false', 'textfordefault' => '', 'text1' => '', 'text2' => 'prints this helptext'},
				'd'  => {'reihenfolge' => '14', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'1', 'default' => '', 'allowIntegratedListIfMultiOption' => 'false', 'textfordefault' => '', 'text1' => '', 'text2' => 'will also log debug-statements.'},

# definition der speziellen options
				'domain-installation-directory' => {'reihenfolge' =>'2', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'string', 'check' => '', 'default' => '', 'allowIntegratedListIfMultiOption' => 'true', 'text1' => "", 'text2' => "das root verzeichnis aller prozess definitionen"},
				'dry' => {'reihenfolge' =>'2', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check' => '', 'default' => '', 'allowIntegratedListIfMultiOption' => 'true', 'text1' => "", 'text2' => "trockenlauf - es werden keine eintraege in der db geaendert"},
);

# die speziellen options in einem array sammeln
my @INPUT_OPTIONS;
push(@INPUT_OPTIONS, "domain-installation-directory");
push(@INPUT_OPTIONS, "dry");

# dynamische standardoptions definieren
# wenn kein dokufile vorhanden ist, wird auch diese option nicht angelegt
if (stat $doc_path)
{
	#$OPTIONS_TABLE{'doc'} = {'reihenfolge' => '20', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'', 'default' => '', 'allowIntegratedListIfMultiOption' => 'false', 'text1' => '', 'text2' => "shows documentation(".Cwd::realpath(File::Spec->rel2abs($doc_path)).")"};
	$OPTIONS_TABLE{'doc'} = {'reihenfolge' => '20', 'minoccur' => '0', 'maxoccur' => '1', 'definition' => 'flag', 'check'=>'', 'default' => '', 'allowIntegratedListIfMultiOption' => 'false', 'text1' => '', 'text2' => "shows documentation"};
}
# wenn kein config-file vorhanden ist, wird auch diese option nicht angelegt
if (stat $conf_path1)
{
	my %CONF_TMP = &getvars($conf_path1);
	$OPTIONS_TABLE{'conf'} = {'reihenfolge' => '21', 'minoccur' => '0', 'maxoccur' => '99', 'definition' => 'string', 'check'=>'^[^=]+=[^=]+$', 'default' => '', 'allowIntegratedListIfMultiOption' => 'false', 'text1' => '=KEY=VALUE', 'text2' => 'for redefinition of configuration variables (possible KEYs are: ' . join(", ", sort keys %CONF_TMP) . ')'};
}
elsif (stat $conf_path2)
{
	my %CONF_TMP = &getvars($conf_path2);
	$OPTIONS_TABLE{'conf'} = {'reihenfolge' => '21', 'minoccur' => '0', 'maxoccur' => '99', 'definition' => 'string', 'check'=>'^[^=]+=[^=]+$', 'default' => '', 'allowIntegratedListIfMultiOption' => 'false', 'text1' => '=KEY=VALUE', 'text2' => 'for redefinition of configuration variables (possible KEYs are: ' . join(", ", sort keys %CONF_TMP) . ')'};
}
# parsen und generieren eines hashs (%optionsall) zum erzeugen von optionen (Getopt::Long)
foreach my $par (keys %OPTIONS_TABLE)
{
	if ( ${$OPTIONS_TABLE{$par}}{'maxoccur'} > 1 )
	{
		my @tmp;
		if (${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
		{
			$optionsall{$par} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "string")
		{
			$optionsall{$par . "=s"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "integer")
		{
			$optionsall{$par . "=i"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "float")
		{
			$optionsall{$par . "=f"} = \@tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "file")
		{
			$optionsall{$par . "=s"} = \@tmp;
		}
		
		$OPT{$par} = \@tmp;
		$OPTHELP{$par} = {'text1' => ${$OPTIONS_TABLE{$par}}{'text1'}, 'text2' => ${$OPTIONS_TABLE{$par}}{'text2'}};
		# dem konfigurierten text1 noch [,STRING] anhaengen falls noetig
		if (${$OPTIONS_TABLE{$par}}{'allowIntegratedListIfMultiOption'} eq "true")
		{
			# das fuehrende '=' in einer kopie entfernen
			my $tmp = ${$OPTIONS_TABLE{$par}}{'text1'};
			$tmp =~ s/^=//;
			
			# den text1 fuer die Usage erweitern
			$OPTHELP{$par}{'text1'} = $OPTHELP{$par}{'text1'} . "[,$tmp]";
		}
		
		if (${$OPTIONS_TABLE{$par}}{'minoccur'} > 0)
		{
			$OPTHELP{$par}{'mandatory'} = 1;
		}
		else
		{
			$OPTHELP{$par}{'mandatory'} = 0;
		}
		
		if (${$OPTIONS_TABLE{$par}}{'default'} =~ m/.+/)
		{
			$OPTHELP{$par}{'default'} = ${$OPTIONS_TABLE{$par}}{'default'};
		}
		else
		{
			$OPTHELP{$par}{'default'} = 0;
		}
	}
	else
	{
		my $tmp;
		if (${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
		{
			$optionsall{$par} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "string")
		{
			$optionsall{$par . "=s"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "integer")
		{
			$optionsall{$par . "=i"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "float")
		{
			$optionsall{$par . "=f"} = \$tmp;
		}
		elsif (${$OPTIONS_TABLE{$par}}{'definition'} eq "file")
		{
			$optionsall{$par . "=s"} = \$tmp;
		}
		
		$OPT{$par} = \$tmp;
		$OPTHELP{$par} = {'text1' => ${$OPTIONS_TABLE{$par}}{'text1'}, 'text2' => ${$OPTIONS_TABLE{$par}}{'text2'}};
		if (${$OPTIONS_TABLE{$par}}{'minoccur'} > 0)
		{
			$OPTHELP{$par}{'mandatory'} = 1;
		}
		else
		{
			$OPTHELP{$par}{'mandatory'} = 0;
		}
		
		if (${$OPTIONS_TABLE{$par}}{'default'} =~ m/.+/)
		{
			$OPTHELP{$par}{'default'} = ${$OPTIONS_TABLE{$par}}{'default'};
		}
		else
		{
			$OPTHELP{$par}{'default'} = 0;
		}
	}
}
# das tatsaechliche erzeugen der options mit Getopt::Long

my $result = GetOptions(%optionsall);
unless($result)
{
	logit('warn', 'problem occured while reading commandline options. information given with unknown options will be ignored. this could be a problem.');
#	exit(1);
}

# VALUES AN KOMMAS SPLITTEN, wenn es die option entsprechend definiert ist (maxoccur > 1, allowIntegratedListIfMultiOption == true)
foreach my $par (sort keys %OPTIONS_TABLE)
{
	if (ref($OPT{$par}) eq "ARRAY")
	{
		if(${$OPTIONS_TABLE{$par}}{'allowIntegratedListIfMultiOption'} eq "true")
		{
			my @newOptionsContent;
			if(&getOption($par))
			{
				foreach my $possiblyCommaSeparatedOption (&getOption($par))
				{
					my $count = ($possiblyCommaSeparatedOption =~ m/,/);
					
					if($count > 0)
					{
						logit("debug", "occurance of option --".$par." has" . ++$count . " entries in form of a comma-separated list ($possiblyCommaSeparatedOption)");
						logit("debug", "these occurances will be treated as they have been called with separate --$par");
						push(@newOptionsContent, split(",", $possiblyCommaSeparatedOption));
					}
					else
					{
						push(@newOptionsContent, $possiblyCommaSeparatedOption);
					}
				}
				&setOption($par, @newOptionsContent);
			}
		}
	}
}

# OPTIONEN DEFAULTS ZUWEISEN
foreach my $par (sort keys %OPTIONS_TABLE)
{
	# wenn eine option vom user nicht gesetzt wurde, aber dafuer ein default-wert existiert, soll dieser gesetzt werden
	
# wenn es ein SCALAR ist
	if (ref($OPT{$par}) eq "SCALAR")
	{
		if (!(${$OPT{$par}}) && ${$OPTIONS_TABLE{$par}}{'default'} && ${$OPTIONS_TABLE{$par}}{'default'} ne "")
		{
			if(${$OPTIONS_TABLE{$par}}{'definition'} eq "flag")
			{
				logit('info', 'setting flag --' . $par);
			}
			else
			{
				logit('info', 'setting default for --' . $par . '=' . ${$OPTIONS_TABLE{$par}}{'default'} );
			}
			my @tmp_defaults = split ("%%", ${$OPTIONS_TABLE{$par}}{'default'});
			${$OPT{$par}} = $tmp_defaults[0];
		}
	}
	
	elsif (ref($OPT{$par}) eq "ARRAY")
	{
		if (!(${$OPT{$par}}[0]) && ${$OPTIONS_TABLE{$par}}{'default'} && ${$OPTIONS_TABLE{$par}}{'default'} ne "")
		{
			logit('info', 'setting default for --' . $par . '=' . ${$OPTIONS_TABLE{$par}}{'default'} );
			@{$OPT{$par}} = split ("%%", ${$OPTIONS_TABLE{$par}}{'default'});
		}
	}
	
}
#----------------------------------------------------------------------------
# prozesskraft:options:end
#============================================================================
#============================================================================
# prozesskraft:config:begin:auto:69119490259240174930277913412752020259
#----------------------------------------------------------------------------
my %CONF;
my %CONF_ORG;

# einlesen des config-files
if (stat $conf_path1)
{
	logit("debug", "config-file found: $conf_path1");
	%CONF_ORG = &getvars($conf_path1);
}
elsif (stat $conf_path2)
{
	logit("debug", "config-file found: $conf_path2");
	%CONF_ORG = &getvars($conf_path2);
}
elsif (stat $conf_path3)
{
	logit("debug", "config-file found: $conf_path3");
	%CONF_ORG = &getvars($conf_path3);
}
else
{
	logit("debug", "no config found in both possible locations (location1: $conf_path1) (location2: $conf_path2) (location3: $conf_path3). builtin config-read capabilities cannot be used");
}

# setzen der vom user uebergebenen configparameter und damit ueberschreiben der bestehenden mit dem gleichen namen
if (&getOption("conf"))
{
	foreach my $conf (&getOption("conf"))
	{
		my @param = split("=", $conf);
		logit("info", "user-driven reconfiguration of " . $conf);
		if (exists $CONF_ORG{$param[0]})
		{
			logit("warn", "reconfiguring parameter (" . $param[0] . "=" . $CONF_ORG{$param[0]} . ") with user value (" . $param[0] . "=" . $param[1] . ")");
			$CONF_ORG{$param[0]} = $param[1];
		}
		else
		{
			logit("fatal", "user config parameter does not exist in configfile (" . $param[0] . ") - ignoring.");
			logit("info", "you only may use these keys as a configuration parameter: " . join (", ", keys %CONF_ORG));
			exit(1);
		}
	}
}

# viele parameter im parameterfile enthalten pfade relativ zum installationsverzeichnis
# diese pfade sollen auf absolute pfade expandiert werden
logit("debug", "expanding config parameter to absolute path");
foreach my $param (sort keys %CONF_ORG)
{
# gibts da ein file? Ja? Dann soll auf den absoluten Pfad expandiert werden
	if ((($CONF_ORG{$param} ne "") && (stat $bindir."/".$CONF_ORG{$param})))
	{
		$CONF{$param} = File::Spec->rel2abs($bindir."/".$CONF_ORG{$param});
		logit("debug", "parameter $param (value=" . $CONF_ORG{$param} .") expanding to (new_value=".$CONF{$param}.")");
	}
	else
	{
		$CONF{$param} = $CONF_ORG{$param};
	}
}
#----------------------------------------------------------------------------
# prozesskraft:config:end
#============================================================================
#============================================================================
# prozesskraft:help:begin:auto:143668985050199644908839921426044606070
#----------------------------------------------------------------------------
my $helptext;

$helptext .= "Description: durchsucht das process installationsverzeichnis nach process.xml, die juenger sind als das process.pdf und stoesst ein neu generieren der dokumentation an.\n";
$helptext .= "\n";
$helptext .= "Usage: $filename PARAMETER\n";
$helptext .= "\n";
$helptext .= "Parameter\n";

for(my $x=0; $x<30; $x++)
{
	foreach(sort keys %OPTHELP)
	{	
		if ( ${$OPTIONS_TABLE{$_}}{'reihenfolge'} == $x )
		{
			$helptext .= sprintf (" --%s%s", $_, ${$OPTHELP{$_}}{'text1'});
	
			if (${$OPTHELP{$_}}{'mandatory'})
			{
				$helptext .= " (mandatory";
			}
			else
			{
				$helptext .= " (optional";
			}
	
			# wenn der default==true und es sich um einen flag-parameter handelt
			if ( (${$OPTHELP{$_}}{'default'} eq "1") && (${$OPTIONS_TABLE{$_}}{'definition'} eq "flag") )
			{
				$helptext .= ", default: on)";
			}
			# wenn der default==false und es sich um einen flag-parameter handelt
			elsif ( (${$OPTHELP{$_}}{'default'} eq "0") && (${$OPTIONS_TABLE{$_}}{'definition'} eq "flag") )
			{
				$helptext .= ", default: off)";
			}
			# wenn es einen default gibt
			elsif ((exists ${$OPTHELP{$_}}{'textfordefault'}) && (${$OPTHELP{$_}}{'textfordefault'}))
			{
				$helptext .= ", default: " . ${$OPTHELP{$_}}{'textfordefault'} . ")";
			}
			elsif (${$OPTHELP{$_}}{'default'})
			{
				$helptext .= ", default: " . ${$OPTHELP{$_}}{'default'} . ")";
			}
			else
			{
				$helptext .= ")";
			}
			$helptext .= "\n";
	
			# helptext nach ca. 66 Zeichen umbrechen
			${$OPTHELP{$_}}{'text2'} =~ s/(.{66}[^\s]*)\s+/$1\n/g;
	
			foreach(split ("\n", ${$OPTHELP{$_}}{'text2'}))
			{
				$helptext .= sprintf ("       %s\n",  $_);
			}
			$helptext .= "\n";
		}
	}
}
$helptext .= "Author : alexander.vogel\@prozesskraft.de\n";
$helptext .= "Date   : $date\n";

if(&getOption('d'))
{
	$helptext .= "Version: $version\n";
}

$helptext .= "\n";
#----------------------------------------------------------------------------
# prozesskraft:help:end
#============================================================================
#============================================================================
# prozesskraft:calls:begin:auto:266109096517382627621986005718768187853
#----------------------------------------------------------------------------
if (getOption("help"))
{
	print STDERR $helptext;
	exit(0);
}
if (getOption("doc"))
{
	if (stat $doc_path)
	{
		logit('info', 'showing documentation');
		exec 'evince ' . $doc_path;
	}
	else
	{
		logit('info', 'no documentation installed ('.$doc_path.')');
	}
	exit(0);
}
#----------------------------------------------------------------------------
# prozesskraft:calls:end
#============================================================================
#============================================================================
# prozesskraft:checks:begin:auto:75637964399854131858600006815504605008
#----------------------------------------------------------------------------
my $error_patternchecks = 0;
my $error_anzahl = 0;

# checken der anzahl der aufrufoptionen
foreach my $key (sort keys %OPT)
{
	my $anzahl = 0;
	if    ( (ref($OPT{$key}) eq "SCALAR") && ( defined(${$OPT{$key}}) ) ) {$anzahl = 1}
	elsif (ref($OPT{$key}) eq "ARRAY") {$anzahl = scalar(@{$OPT{$key}});}
	
	# minoccur checken
	if ( ${$OPTIONS_TABLE{$key}}{'minoccur'} > $anzahl )
	{
		if ( ${$OPTIONS_TABLE{$key}}{'minoccur'} == 1 && ${$OPTIONS_TABLE{$key}}{'maxoccur'} == 1)
		{
			logit('error', 'option --'.$key.' needed.');
		}
		elsif ( ${$OPTIONS_TABLE{$key}}{'minoccur'} < ${$OPTIONS_TABLE{$key}}{'maxoccur'})
		{
			logit('error', 'option --'.$key.' needed at least '.${$OPTIONS_TABLE{$key}}{'minoccur'}.' times.');
		}
		$error_anzahl++;
	}
	# maxoccur checken
	if ( ${$OPTIONS_TABLE{$key}}{'maxoccur'} < $anzahl )
	{
		logit('error', 'option --'.$key.' may only be used '.${$OPTIONS_TABLE{$key}}{'maxoccur'}.' times.');
		$error_anzahl++;
	}
}

# checken des inhalts der aufrufoptionen
foreach my $key (sort keys %OPT)
{
	my $anzahl = 0;
	if ( (ref($OPT{$key}) eq "SCALAR") && ( defined(${$OPT{$key}}) ) )
	{
		unless (${$OPT{$key}} =~ m/${$OPTIONS_TABLE{$key}}{'check'}/)
		{
			logit('error', 'option --'.$key.'='.${$OPT{$key}}.' is not a ' . ${$OPTIONS_TABLE{$key}}{'definition'}.  ' (does not match the expected pattern /'.${$OPTIONS_TABLE{$key}}{'check'}.'/).');
			$error_patternchecks++;
		}
	}
	
	elsif ( (ref($OPT{$key}) eq "ARRAY") && (scalar(@{$OPT{$key}})) )
	{
		foreach my $value (@{$OPT{$key}})
		{
			unless ($value =~ m/${$OPTIONS_TABLE{$key}}{'check'}/)
			{
				logit('error', 'option --'.$key.'='.$value.' is not a ' . ${$OPTIONS_TABLE{$key}}{'definition'}.  ' (does not match the expected pattern /'.${$OPTIONS_TABLE{$key}}{'check'}.'/).');
				$error_patternchecks++;
			}
		}
	}
}


if ($error_anzahl + $error_patternchecks)
{
	logit('fatal', $error_anzahl + $error_patternchecks .' error(s) found in call. call --help for help. exit.');
	exit(1);
}
#----------------------------------------------------------------------------
# prozesskraft:checks:end
#============================================================================
#============================================================================
# prozesskraft:business:begin:auto:323924951525767987916855845735749986327
#----------------------------------------------------------------------------
#
# to deal with configuration variables, use...
# getConfig(<key>) to obtain information defined in the config file
# setConfig(<key>, <value>) to set a configuration value
# getConfigKeys() to obtain all keys used in the config file
#
# to deal with user call options, use...
# getOption(<key>) to get the value of a certain option
# setOption(<string>, <value>) to redefine a certain option. option has to be known to the program.
# getOptionKeys() to obtain all used options
# addOption(<string>, <key>) to add a value to an option. option has to be a multioption and declared in the options block.
#
# you may use @ARG for all unknown/unparsed options given. this makes writing wrapperscripts easier.
#
# for logging use ...
# logit("info", "some log information");
#
# place your business logic here.
#
{
	# feststellen des installations verzeichnisses
	my $domain_installation_directory;

	if(getOption("domain-installation-directory"))
	{
		$domain_installation_directory = getOption("domain-installation-directory");
	}
	elsif(getConfig("domain-installation-directory"))
	{
		$domain_installation_directory = getConfig("domain-installation-directory");
	}
	else
	{
		&logit("fatal", "you need to give domain-installation-directory either as an option or as an config entry");
		exit(1);
	}

	# existiert das verzeichnis?
	if(!(-d $domain_installation_directory))
	{
		&logit("fatal", "domain-installation-directory does not exist");
		exit(1);
	}

	# feststellen der domains
	my @domainDirs;
	opendir (DIR, $domain_installation_directory) or die $!;
	my @dir = readdir DIR;
	foreach my $item (@dir)
	{
		next if($item =~ m/^\./);
		push(@domainDirs, $domain_installation_directory . "/" . $item);
		logit("debug", "domainDir: " . $domain_installation_directory . "/" . $item);
	}
	closedir DIR;

	# feststellen der domainProzessDirs
	my @domainProcessDirs;
	foreach my $domainDir (@domainDirs)
	{
		opendir (DIR, $domainDir) or die $!;
		my @dir = readdir DIR;
		foreach my $item (@dir)
		{
			next if($item =~ m/^\./);
			push(@domainProcessDirs, $domainDir . "/" . $item);
			logit("debug", "domainProcessDir: " . $domainDir . "/" . $item);
		}
		closedir DIR;
	}

	# feststellen der domainProzessVersionDirs
	my @domainProcessVersionDirs;
	foreach my $domainProcessDir (@domainProcessDirs)
	{
		opendir (DIR, $domainProcessDir) or die $!;
		my @dir = readdir DIR;
		foreach my $item (@dir)
		{
			next if($item =~ m/^\./);
			push(@domainProcessVersionDirs, $domainProcessDir . "/" . $item);
			logit("debug", "domainProcessVersionDir: " . $domainProcessDir . "/" . $item);
		}
		closedir DIR;
	}

	# alle prozessInstallationVerzeichnisse durchgehen und fuer jeden process.xml, der kein process.pdf hat oder das process.pdf aelter ist, soll ein createdoc durchgefuehrt werden
	foreach my $domainProcessVersionDir (@domainProcessVersionDirs)
	{
		opendir (DIR, $domainProcessVersionDir) or die $!;
		my @dir = readdir DIR;
		my @statXml;
		my @statPdf;
		foreach my $item (@dir)
		{
			if($item =~ m/^process.xml$/)
			{
				@statXml = stat $domainProcessVersionDir . "/" . $item;
			}
			if($item =~ m/^process.pdf$/)
			{
				@statPdf = stat $domainProcessVersionDir . "/" . $item;
			}
		}
		closedir DIR;
		
		if(@statXml)
		{
			if(@statPdf && $statPdf[9] > $statXml[9])
			{
				&logit("info", "process.pdf is older than the process.xml");
				
				# ein X framebuffer falls das hier headless gestartet wurde
				my $precall = "Xvfb :77 > /dev/null &";
				
				# change env DISPLAY
				$ENV{DISPLAY} = ":77";
				
				my $call = &getConfig("pkraft-createdoc") . " -definition " . $domainProcessVersionDir . "/process.xml -output " . $domainProcessVersionDir . "/process.pdf";
				
				&logit("info", "deleting existent process.pdf: " . $domainProcessVersionDir . "/process.pdf");
				unlink $domainProcessVersionDir . "/process.pdf";
				
				&logit("info", "generating fresh documentation");
				&logit("info", $call);

				# das generieren ausfuehren
				unless(getOption("dry"))
				{
					# starten framebuffer
					logit("info", "calling: " . $precall);
					my $rueckPrecall = system($precall);
					
					# starten createdoc
					logit("info", "calling: " . $call);
					my $rueck = system($call);

					# fehlerhandling - setzen des zeitstempels auf 0
					if($rueck)
					{
						utime 0, 0, $domainProcessVersionDir . "/process.pdf";
	 				}
				}
			}
			elsif(@statPdf)
			{
				&logit("info", "process.pdf found. pdf is younger than the model. doing nothing");
			}
			else
			{
				&logit("info", "no process.pdf found");
				my $call = &getConfig("pkraft-createdoc") . " -definition " . $domainProcessVersionDir . "/process.xml -output " . $domainProcessVersionDir . "/process.pdf";
				
				&logit("info", "generating documentation");
				&logit("info", $call);
				
				# das generieren ausfuehren
				unless(getOption("dry"))
				{
					my $rueck = system(split(" ", $call));

					# fehlerhandling - setzen des zeitstempels auf 0
					if($rueck)
					{
						utime 0, 0, $domainProcessVersionDir . "/process.pdf";
	 				}
				}
			}
		}
		else
		{
			&logit("info", "no process.xml found");
		}
	}
}
#
#----------------------------------------------------------------------------
# prozesskraft:business:end
#============================================================================
#============================================================================
# prozesskraft:subs:begin:auto:302387158958954620797460673004408239692
#----------------------------------------------------------------------------
sub getvars
{
    my $fp_conf = shift;

    my %CONF;
    if (!open (CONF, "<$fp_conf")) {die "cannot read $fp_conf $!\n";}
    
    while(<CONF>)
    {
        if    ( $_ =~ m/^#/) {next}
        elsif ( $_ =~ m/^$/) {next}
		elsif ( $_ =~ m/^\s*$/) {next}
        else
        {
            my @tmp = split('=', $_);
            
        	# falls unwahr, soll der parameter einen leeren string erhalten
        	unless ($tmp[1]) {$tmp[1] = '';}
        	
        	$tmp[0] =~ s/\s$//g;
        	$tmp[0] =~ s/^\s//g;
        	$tmp[1] =~ s/\s$//g;
        	$tmp[1] =~ s/^\s//g;
        			
            $CONF{$tmp[0]} = $tmp[1];
        }
    }
    close CONF;
    return %CONF;
}
sub logit
{
	if (scalar(@_) < 2) {die "wrong call on subroutine 'logit'";}
	my $level = shift;
	my $msg = shift;
	my $dest;
	if (@_)
	{
		$dest = shift;
	}
	
# wenn loglevel == debug, ABER --debug nicht gesetzt wurde, soll nicht geloggt werden
		if ( ($level eq "debug") &! (getOption("debug") ||  getOption("d")) )
		{
			return;
		}

	my $timestamp = localtime(time);
	
	my $ausgabestring = '[' . $timestamp . ']:' . $level . ':' . $msg; 
	
	if (!($dest))
	{
		print STDERR $ausgabestring."\n";
	}
	elsif ($dest =~ m/^stderr$/i)
	{
		print STDERR $ausgabestring."\n";
	}
	elsif ($dest =~ m/^stdout$/i)
	{
		print STDOUT $ausgabestring."\n";
	}
	elsif (($dest) && (stat $dest))
	{
		system 'echo $ausgabestring >> $dest';
	}
	else
	{
		print STDERR 'unknown logging destination $dest (file does not exist)' . '. assuming stderr';
		print STDERR $ausgabestring."\n";
	}
}

sub getOptionKeys
{
	return sort keys %OPT;
}

sub getOption
{
	my $key = shift;
	
	# wenn option nicht existiert oder die anzahl der values innerhalb der option = 0 ist
	if (!(defined $OPT{$key}))
	{
		return undef;
	}
	
	elsif (ref($OPT{$key}) eq "SCALAR")
	{
		if (!defined ${$OPT{$key}})
		{
			return undef;
		}
		else
		{
			return ${$OPT{$key}}
		}
	}
	
	elsif (ref($OPT{$key}) eq "ARRAY")
	{
		if ( (! @{$OPT{$key}}) || (scalar @{$OPT{$key}} == 0) )
		{
			return undef;
		}
		# wenn es genau eine value fuer die option gibt 
		elsif (scalar(@{$OPT{$key}}) == 1)
		{
			return ${$OPT{$key}}[0]
		}
		# wenn es mehrere values fuer die option gibt
		else
		{
			return @{$OPT{$key}}
		}
	}
}

sub setOption
{
	my $key = shift;
	
	if (ref($OPT{$key}) eq "SCALAR")
	{
		if (@_ > 1)
		{
			&logit("error", "cannot apply a list (@_) to a scalar option ($key).");
		}
		
		else
		{
			${$OPT{$key}} = $_[0];
		}
	}
	
	elsif (ref($OPT{$key}) eq "ARRAY")
	{
		@{$OPT{$key}} = @_;
	}
}

sub addOption
{
	my $key = shift;
	
	if (ref($OPT{$key}) eq "ARRAY")
	{
		push @{$OPT{$key}}, @_;
	}
}

sub getConfigKeys
{
	return sort keys %CONF;
}

sub getConfig
{
	my $key = shift;
	if (defined $CONF{$key})
	{
		return $CONF{$key};
	}
}

sub setConfig
{
	my $key = shift;
	my $value = shift;
	
	$CONF{$key} = $value;
}

sub importOptionToHash
{
	
	my $type = shift;
	my $refh_HASH = shift;
	my $option = shift;
	
	logit('debug', "importing option $option into process-specific $type-category into step root");
	
	# wenn es ein file ist, soll der pfad expanded werden
	if( $type eq 'file' )
	{
		my @allValuesOfACertainOption;
		
		# die option --commitfiledummy muss besonders behandelt werden
		if($option eq 'commitfiledummy')
		{
			my $key = undef;
			my $value = undef;
			
			if(getOption($option))
			{
				@allValuesOfACertainOption = getOption($option);
			}
			foreach my $actValue (@allValuesOfACertainOption)
			{
				my @actValue = split('=', $actValue);
				if(@actValue>1)
				{
					$key = shift @actValue;
					$value = join('=', @actValue);
				}
				else
				{
					$key = shift @actValue;
					$value = $key;
				}
				if(stat $value)
				{
					push(@{$$refh_HASH{'root'}}, [$key, File::Spec->rel2abs($value)]);
				}
				else
				{
					logit('error', "option $option has to be a file. file not found: $value");
					exit(1)
				}
			}
		}
		# alle anderen options
		else
		{
			if(getOption($option))
			{
				@allValuesOfACertainOption = getOption($option);
			}
			foreach my $actValue (@allValuesOfACertainOption)
			{
				if(stat $actValue)
				{
					push(@{$$refh_HASH{'root'}}, [$option, File::Spec->rel2abs($actValue)]);
				}
				else
				{
					logit('error', "option $option has to be a file. file not found: $actValue");
					exit(1)
				}
			}
		}
	}
	# wenn es eine variable ist, einfach uebernehmen
	elsif( $type eq 'variable' )
	{
		my @allValuesOfACertainOption;
		
		# die option --commitvariabledummy muss besonders behandelt werden
		if($option eq 'commitvariabledummy')
		{
			my $key = undef;
			my $value = undef;
			
			if(getOption($option))
			{
				@allValuesOfACertainOption = getOption($option);
			}
			foreach my $actValue (@allValuesOfACertainOption)
			{
				my @actValue = split('=', $actValue);
				if(@actValue>1)
				{
					$key = shift @actValue;
					$value = join('=', @actValue);
				}
				else
				{
					$key = shift @actValue;
					$value = $key;
				}
				push(@{$$refh_HASH{'root'}}, [$key, File::Spec->rel2abs($value)]);
			}
		}
		# alle anderen options
		else
		{
			if(getOption($option))
			{
				@allValuesOfACertainOption = getOption($option);
			}
			foreach my $actValue (@allValuesOfACertainOption)
			{
				push(@{$$refh_HASH{'root'}}, [$option, $actValue]);
			}
		}
	}
	
	else
	{
		logit('fatal', "unknown type $type. only permitted one of these: variable OR file");
		exit(1);
	}
	
}

sub addFilesEtc
{
	my $refh_FILE = shift;
	
# existiert ein etc-verzeichnis?
	if(-d $etcdir)
	{
		# filesliste des etc-directories ermitteln
		opendir(ETC, $etcdir);
		my @fileOfEtc = grep{ $_ !~ m/^\./ } readdir(ETC);
		
		&logit("debug", "adding " . scalar(@fileOfEtc) . " files from <installdir>/etc to list 'installetc' of step 'root'");
		
		foreach my $fileOfEtc (@fileOfEtc)
		{
			push(@{$$refh_FILE{'root'}}, ["subdiretc", File::Spec->rel2abs($etcdir . "/" . $fileOfEtc)]);
			&logit("debug", "adding to 'root': subdiretc=" . File::Spec->rel2abs($etcdir . "/" . $fileOfEtc));
		}
	}
	else
	{
		&logit("debug", "kein etc-verzeichnis vorhanden -> es werden keine etc-dateien in den root-step importiert");
	}
}


#----------------------------------------------------------------------------
# prozesskraft:subs:end
#============================================================================
